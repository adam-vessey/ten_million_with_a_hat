<?php

/**
 * @file
 * Places page objects in a single book.
 */

/**
 * Implements hook_ten_million_with_a_hat_also_do_these_things().
 */
function hats_in_a_book_ten_million_with_a_hat_also_do_these_things() {
  global $user;
  $tuque = islandora_get_tuque_connection();
  $book = $tuque->repository->constructObject('book');
  $book->label = "Book hat";
  $book->owner = $user->name;
  $book->models = (array) 'islandora:bookCModel';
  $book->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', 'islandora:bookCollection');
  $tuque->repository->ingestObject($book);
  cache_set('hats_in_a_book_id', $book->id);
  cache_set('hats_in_a_book_current_page', 1);
  return array(
    'Put the page hats in a book!' => array(
      'callback' => 'hats_in_a_book_add_to_book',
      'args' => array($book->id),
    ),
  );
}

/**
 * Implements hook_ten_million_with_a_hat_also_say_these_things().
 */
function hats_in_a_book_ten_million_with_a_hat_also_say_these_things() {
  $book = cache_get('hats_in_a_book_id');
  $book = $book->data;
  return array(
    array(
      'type' => 'before_batch',
      'message' => "Ingesting all pages into the book object $book.",
    ),
    array(
      'type' => 'between_ingests',
      'callback' => 'hats_in_a_book_between_ingests_message_callback',
      'args' => array($book),
    ),
    array(
      'type' => 'after_batch',
      'callback' => 'hats_in_a_book_after_batch_message_callback',
      'args' => array($book),
    ),
  );
}

/**
 * Adds the page to a book, if necessary.
 *
 * @param AbstractObject $object
 *   The object to add to the book if it's a page.
 * @param string $book
 *   The PID of the book to add the pages to.
 */
function hats_in_a_book_add_to_book(AbstractObject $object, $book) {
  if (in_array('islandora:pageCModel', $object->models)) {
    // Add the page to the book.
    module_load_include('inc', 'islandora_paged_content', 'includes/utilities');
    $current_page = cache_get('hats_in_a_book_current_page');
    $current_page = $current_page->data;
    islandora_paged_content_set_relationship($object->relationships, ISLANDORA_RELS_EXT_URI, 'isPageOf', $book);
    islandora_paged_content_set_relationship($object->relationships, ISLANDORA_RELS_EXT_URI, 'isSequenceNumber', $current_page);
    islandora_paged_content_set_relationship($object->relationships, ISLANDORA_RELS_EXT_URI, 'isPageNumber', $current_page);
    islandora_paged_content_set_relationship($object->relationships, ISLANDORA_RELS_EXT_URI, 'isSection', 1);
    islandora_paged_content_set_relationship($object->relationships, FEDORA_RELS_EXT_URI, 'isMemberOf', $book);
    $current_page++;
    cache_set('hats_in_a_book_current_page', $current_page);
  }
}

/**
 * Between ingests callback for ingested pages.
 *
 * @param AbstractObject $object
 *   The page object that was ingested into the book, potentially.
 * @param string $book
 *   The PID of the book we potentially ingested the page into.
 *
 * @return string|null
 *   A message describing the page relationship between the book and page, or
 *   NULL if $object isn't a page.
 */
function hats_in_a_book_between_ingests_message_callback(AbstractObject $object, $book) {
  if (in_array('islandora:pageCModel', $object->models)) {
    // The page counter will have been incremented already, so subtract 1.
    $page = cache_get('hats_in_a_book_current_page');
    $page = $page->data - 1;
    return "Set $object->id as page $page of book object $book.";
  }
  return NULL;
}

/**
 * After batch callback to clean the cache and re-report the ingested book.
 *
 * @param string $book
 *   The PID of the book we ingested any pages into.
 *
 * @return string
 *   A message re-reporting the PID of the book.
 */
function hats_in_a_book_after_batch_message_callback($book) {
  cache_clear_all('hats_in_a_book_id', 'cache');
  cache_clear_all('hats_in_a_book_current_page', 'cache');
  return "All page objects have been ingested into the book object $book.";
}
