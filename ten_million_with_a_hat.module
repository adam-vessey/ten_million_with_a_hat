<?php

/**
 * @file
 * 🔟Ⓜ️ w/ 🎩.
 */

/**
 * Does the thing with the stuff.
 *
 * @param int $objects
 *   How many things we wanna do stuff with.
 * @param array|null $exclude
 *   An array of solution pack PIDs to exclude, or NULL if unused.
 * @param array|null $restrict
 *   An array of solution pack PIDs to restrict the list to, or NULL if unused.
 * @param string $namespace
 *   The namespace to assign to ingested objects.
 *
 * @return array
 *   The batch array thingy.
 */
function ten_million_with_a_hat_ingest_batch($objects, $exclude, $restrict, $namespace) {
  global $user;
  return array(
    'title' => t('Ten Million With A Hat Batch Ingest'),
    'init_message' => ("Preparing to ingest $objects objects ..."),
    'progress_message' => t('Time elapsed: @elapsed <br/>Estimated time remaining @estimate.'),
    'error_message' => t('An error has occured.'),
    'file' => drupal_get_path('module', 'ten_million_with_a_hat') . '/ten_million_with_a_hat.module',
    'operations' => array(
      array(
        'ten_million_with_a_hat_ingest_batch_operation',
        array($objects, $user, $exclude, $restrict, $namespace),
      ),
    ),
  );
}

/**
 * Processes the thing with the stuff.
 *
 * @param int $objects
 *   The number of objects we're creating.
 * @param object $user
 *   The logged in user.
 * @param array|null $exclude
 *   An array of solution pack PIDs to exclude, or NULL if unused.
 * @param array|null $restrict
 *   An array of solution pack PIDS to restrict the list to, or NULL if unused.
 * @param string $namespace
 *   The namespace to assign to ingested objects.
 * @param array $context
 *   The batch context.
 */
function ten_million_with_a_hat_ingest_batch_operation($objects, $user, $exclude, $restrict, $namespace, &$context) {
  $sandbox = &$context['sandbox'];
  if (empty($sandbox)) {
    $context['finished'] = 0;
    $sandbox['completed'] = 0;
    $sandbox['total'] = $objects;
    $sandbox['collections'] = ten_million_with_a_hat_get_collection_pid_array($exclude, $restrict);
    $sandbox['other_stuff'] = module_invoke_all('ten_million_with_a_hat_also_do_these_things');
    uasort($sandbox['other_stuff'], 'drupal_sort_weight');
  }
  if (!empty($sandbox['collections'])) {
    $collection = islandora_object_load(ten_million_with_a_hat_get_random_array_member(array_keys($sandbox['collections'])));
    $model = ten_million_with_a_hat_get_random_array_member($sandbox['collections'][$collection->id]);
    // Let's make an object wheeeee.
    $tuque = islandora_get_tuque_connection();
    $object = $tuque->repository->constructObject($namespace);
    $object->label = DrupalTestCase::randomName();
    $object->owner = $user->name;
    $object->models = (array) $model;
    $tuque->repository->ingestObject($object);
    $object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collection->id);
    // If we have other things to do, do e'm.
    foreach ($sandbox['other_stuff'] as $thing_to_do) {
      if (isset($thing_to_do['file'])) {
        module_load_include($thing_to_do['file']['type'], $thing_to_do['file']['module'], $thing_to_do['file']['path']);
      }
      $args = array($object);
      if (isset($thing_to_do['args'])) {
        array_unshift($args, $thing_to_do['args']);
      }
      call_user_func_array($thing_to_do['callback'], $args);
    }
    $sandbox['completed']++;
    $context['message'] = "{$sandbox['completed']}/{$sandbox['total']}: Ingested {$object->id} into {$collection->id} with model $model.";
    $context['finished'] = $sandbox['completed'] / $sandbox['total'];
  }

  // Handle the case where your repository is so messed up that there are no
  // valid collections, or where $restrict manages to restrict everything.
  else {
    $context['message'] = is_null($restrict) ? "For some reason, no valid collections with policies were found in your repository, so we can't really do anything." : "No valid collections were found using the restricted content model(s).";
    $context['finished'] = 1;
  }
}

/**
 * Raaaaaaandom! This description ends in a full stop, so THERE, coder-review.
 *
 * @param array $array
 *   An array wheeeee.
 *
 * @return string
 *   A random member of the string
 */
function ten_million_with_a_hat_get_random_array_member($array) {
  return $array[mt_rand(0, count($array) - 1)];
}

/**
 * Returns the list of existing collections as PIDs.
 *
 *
 * @param array|null $exclude
 *   An array of solution pack PIDs to exclude, or NULL if unused.
 * @param array|null $restrict
 *   An array of solution pack PIDs to restrict the list to, or NULL if unused.
 *
 * @return array
 *   The PID array.
 */
function ten_million_with_a_hat_get_collection_pid_array($exclude, $restrict) {
  $collections = islandora_basic_collection_get_collections();
  $pids = array();
  foreach ($collections as $collection) {
    $pids[$collection['pid']] = array();
    $loaded_collection = islandora_object_load($collection['pid']);
    if (!isset($loaded_collection['COLLECTION_POLICY'])) {
      unset($pids[$collection['pid']]);
    }
    else {
      $models = ten_million_with_a_hat_get_content_models(islandora_object_load($collection['pid']));
      if ($models) {
        $pids[$collection['pid']] = $models;

        // Figure out restriction.
        if (is_array($restrict)) {
          dd($pids[$collection['pid']]);
          dd($restrict);
          $pids[$collection['pid']] = array_values(array_intersect($pids[$collection['pid']], $restrict));
        }
        // No restriction? Figure out exclusion.
        elseif (is_array($exclude)) {
          $pids[$collection['pid']] = array_values(array_diff($pids[$collection['pid']], $exclude));
        }
        // Neither are an array? Default to including all.
        else {
          $pids[$collection['pid']] = array_values($pids[$collection['pid']]);
        }

        // If that process leaves the PID set empty, dump that collection.
        if (empty($pids[$collection['pid']])) {
          unset($pids[$collection['pid']]);
        }
      }
      else {
        unset($pids[$collection['pid']]);
      }
    }
  }
  return $pids;
}

/**
 * Gets the content models from the collection policy.
 *
 * @param AbstractObject $collection
 *   The collection to get the policy from.
 *
 * @return string|bool
 *   A random content model PID, or FALSE on failure.
 */
function ten_million_with_a_hat_get_content_models(AbstractObject $collection) {
  // It should be guaranteed to have a collection policy by the time we get to
  // this point, but you just never know what some people are gonna do.
  try {
    $policy = new CollectionPolicy($collection['COLLECTION_POLICY']->content);
  }
  catch (Exception $e) {
    return FALSE;
  }
  return array_keys($policy->getContentModels());
}
