<?php

/**
 * @file
 * 🔟Ⓜ️ w/ 🎩.
 */

/**
 * Does the thing with the stuff.
 *
 * @param int $objects
 *   How many things we wanna do stuff with.
 * @param array $cm_set
 *   An array containing a 'type' of 'exclude' or 'restrict', as well as a
 *   'pids' array of content model PIDs to perform the 'type' operation on.
 * @param array $collection_set
 *   An array containing a 'type' of 'exclude' or 'restrict', as well as a
 *   'pids' array of collection PIDs to perform the 'type' operation on.
 * @param string $namespace
 *   The namespace to assign to ingested objects.
 *
 * @return array
 *   The batch array thingy.
 */
function ten_million_with_a_hat_ingest_batch($objects, $cm_set, $collection_set, $namespace) {
  global $user;
  return array(
    'title' => t('Ten Million With A Hat Batch Ingest'),
    'init_message' => ("Preparing to ingest $objects objects ..."),
    'progress_message' => t('Time elapsed: @elapsed <br/>Estimated time remaining @estimate.'),
    'error_message' => t('An error has occured.'),
    'file' => drupal_get_path('module', 'ten_million_with_a_hat') . '/ten_million_with_a_hat.module',
    'operations' => array(
      array(
        'ten_million_with_a_hat_ingest_batch_operation',
        array($objects, $user, $cm_set, $collection_set, $namespace),
      ),
    ),
  );
}

/**
 * Processes the thing with the stuff.
 *
 * @param int $objects
 *   The number of objects we're creating.
 * @param object $user
 *   The logged in user.
 * @param array $cm_set
 *   The content model set array defined by ten_million_with_a_hat_ingest_batch.
 * @param array $collection_set
 *   The collection set array defined by ten_million_with_a_hat_ingest_batch.
 * @param string $namespace
 *   The namespace to assign to ingested objects.
 * @param array $context
 *   The batch context.
 */
function ten_million_with_a_hat_ingest_batch_operation($objects, $user, $cm_set, $collection_set, $namespace, &$context) {
  $sandbox = &$context['sandbox'];
  if (empty($sandbox)) {
    $context['finished'] = 0;
    $sandbox['completed'] = 0;
    $sandbox['total'] = $objects;
    $sandbox['collections'] = ten_million_with_a_hat_get_collection_pid_array($cm_set, $collection_set);
    $sandbox['other_stuff'] = module_invoke_all('ten_million_with_a_hat_also_do_these_things');
    $sandbox['messages'] = module_invoke_all('ten_million_with_a_hat_also_say_these_things');
    uasort($sandbox['other_stuff'], 'drupal_sort_weight');
    uasort($sandbox['messages'], 'drupal_sort_weight');
    foreach ($sandbox['messages'] as $message) {
      if ($message['type'] === 'before_batch') {
        $parsed_message = ten_million_with_a_hat_parse_message($message);
        if (!is_null($parsed_message)) {
          $context['message'] = $parsed_message;
        }
      }
    }
  }
  if (!empty($sandbox['collections'])) {
    $collection = islandora_object_load(ten_million_with_a_hat_get_random_array_member(array_keys($sandbox['collections'])));
    $model = ten_million_with_a_hat_get_random_array_member($sandbox['collections'][$collection->id]);
    // Let's make an object wheeeee.
    $tuque = islandora_get_tuque_connection();
    $object = $tuque->repository->constructObject($namespace);
    $object->label = DrupalTestCase::randomName();
    $object->owner = $user->name;
    $object->models = (array) $model;
    $tuque->repository->ingestObject($object);
    $object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collection->id);
    // If we have other things to do, do e'm.
    foreach ($sandbox['other_stuff'] as $thing_to_do) {
      if (isset($thing_to_do['file'])) {
        module_load_include($thing_to_do['file']['type'], $thing_to_do['file']['module'], $thing_to_do['file']['path']);
      }
      $args = array($object);
      if (isset($thing_to_do['args'])) {
        $args = array_merge($args, $thing_to_do['args']);
      }
      call_user_func_array($thing_to_do['callback'], $args);
    }
    $sandbox['completed']++;

    // First, print out the ingest message.
    $context['message'] = "{$sandbox['completed']}/{$sandbox['total']}: Ingested {$object->id} into {$collection->id} with model $model.";
    // Then, say anything else we need to.
    foreach ($sandbox['messages'] as $message) {
      if ($message['type'] === 'between_ingests') {
        $parsed_message = ten_million_with_a_hat_parse_message($message, $object);
        if (!is_null($parsed_message)) {
          $context['message'] = $parsed_message;
        }
      }
    }

    // See if we're finished, and if we are, print all the finished messages.
    $context['finished'] = $sandbox['completed'] / $sandbox['total'];
    if ($context['finished'] === 1) {
      foreach ($sandbox['messages'] as $message) {
        if ($message['type'] === 'after_batch') {
          $parsed_message = ten_million_with_a_hat_parse_message($message);
          if (!is_null($parsed_message)) {
            $context['message'] = $parsed_message;
          }
        }
      }
    }
  }

  // Handle the case where your repository is so messed up that there are no
  // valid collections, or where $restrict manages to restrict everything.
  else {
    $context['message'] = is_null($restrict) ? "For some reason, no valid collections with policies were found in your repository, so we can't really do anything." : "No valid collections were found using the restricted content model(s).";
    $context['finished'] = 1;
  }
}

/**
 * Raaaaaaandom! This description ends in a full stop, so THERE, coder-review.
 *
 * @param array $array
 *   An array wheeeee.
 *
 * @return string
 *   A random member of the string
 */
function ten_million_with_a_hat_get_random_array_member($array) {
  return $array[mt_rand(0, count($array) - 1)];
}

/**
 * Returns the list of existing collections as PIDs.
 *
 * @param array $cm_set
 *   The content model set array defined by ten_million_with_a_hat_ingest_batch.
 * @param array $collection_set
 *   The collection set array defined by ten_million_with_a_hat_ingest_batch.
 *
 * @return array
 *   The PID array.
 */
function ten_million_with_a_hat_get_collection_pid_array($cm_set, $collection_set) {
  // Hooookay. First, let's get a collection PID array.
  $collections = array_values(array_map(function($collection) {
    return $collection['pid'];
  }, islandora_basic_collection_get_collections()));
  $pids = array();

  // Now, let's filter the collection list.
  switch ($collection_set['type']) {
    case 'restrict':
      $collections = array_intersect($collections, $collection_set['pids']);
      break;

    case 'exclude':
      $collections = array_diff($collections, $collection_set['pids']);
      break;
  }

  // Alright, now to filter the content models.
  foreach ($collections as $collection) {
    $pids[$collection] = array();
    $loaded_collection = islandora_object_load($collection);
    if (!isset($loaded_collection['COLLECTION_POLICY'])) {
      unset($pids[$collection]);
    }
    else {
      $models = ten_million_with_a_hat_get_content_models(islandora_object_load($collection));
      if ($models) {
        $pids[$collection] = $models;

        // Figure out restriction or exclusion of content models.
        switch ($cm_set['type']) {
          case 'restrict':
            $pids[$collection] = array_values(array_intersect($pids[$collection], $cm_set['pids']));
            break;

          case 'exclude':
            $pids[$collection] = array_values(array_diff($pids[$collection], $cm_set['pids']));
            break;

        }
        // If that process leaves the PID set empty, dump that collection.
        if (empty($pids[$collection])) {
          unset($pids[$collection]);
        }
      }
      else {
        unset($pids[$collection]);
      }
    }
  }
  return $pids;
}

/**
 * Gets the content models from the collection policy.
 *
 * @param AbstractObject $collection
 *   The collection to get the policy from.
 *
 * @return string|bool
 *   A random content model PID, or FALSE on failure.
 */
function ten_million_with_a_hat_get_content_models(AbstractObject $collection) {
  // It should be guaranteed to have a collection policy by the time we get to
  // this point, but you just never know what some people are gonna do.
  try {
    $policy = new CollectionPolicy($collection['COLLECTION_POLICY']->content);
  }
  catch (Exception $e) {
    return FALSE;
  }
  return array_keys($policy->getContentModels());
}

/**
 * Takes a message callback and arguments and turns it into a message.
 *
 * @param array $callback
 *   The callback array returned by the also_say_these_things hook, containing
 *   at least a 'callback' string and a 'type' string, and possibly an 'args'
 *   array. If a 'message' string is found, it just returns that.
 * @param AbstractObject|null $object
 *   The object currently being worked with. If it's needed, pass it in, and it
 *   will be set as the first parameter when the callback is run; otherwise,
 *   just leave it as NULL.
 *
 * @return string|null
 *   The parsed message to display, or NULL if nothing can be displayed.
 */
function ten_million_with_a_hat_parse_message($callback, $object = NULL) {
  if (isset($callback['message'])) {
    return $callback['message'];
  }
  if (!isset($callback['callback'])) {
    return NULL;
  }

  $args = array();
  if (is_object($object) && is_subclass_of($object, 'AbstractObject')) {
    $args[] = $object;
  }
  if (isset($callback['args'])) {
    $args = array_merge($args, $callback['args']);
  }
  return call_user_func_array($callback['callback'], $args);
}
